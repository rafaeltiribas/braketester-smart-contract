package fptower

import "github.com/consensys/gnark-crypto/ecc/bw6-756/fp"

func (z *E6) nSquare(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquare(z)
	}
}

func (z *E6) nSquareCompressed(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquareCompressed(z)
	}
}

// Expt set z to x^t in E6 and return z
func (z *E6) Expt(x *E6) *E6 {

	// Expt computation is derived from the addition chain:
	//
	//	_1000     = 1 << 3
	//	_1001     = 1 + _1000
	//	_1001000  = _1001 << 3
	//	_1010001  = _1001 + _1001000
	//	_10011001 = _1001000 + _1010001
	//	i67       = ((_10011001 << 5 + _1001) << 10 + _1010001) << 41
	//	return      1 + i67
	//
	// Operations: 62 squares 6 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var result, t0, t1 E6

	// Step 3: result = x^0x8
	result.CyclotomicSquare(x)
	result.nSquare(2)

	// Step 4: t0 = x^0x9
	t0.Mul(x, &result)

	// Step 7: t1 = x^0x48
	t1.CyclotomicSquare(&t0)
	t1.nSquare(2)

	// Step 8: result = x^0x51
	result.Mul(&t0, &t1)

	// Step 9: t1 = x^0x99
	t1.Mul(&t1, &result)

	// Step 14: t1 = x^0x1320
	t1.nSquare(5)

	// Step 15: t0 = x^0x1329
	t0.Mul(&t0, &t1)

	// Step 25: t0 = x^0x4ca400
	t0.nSquare(10)

	// Step 26: result = x^0x4ca451
	result.Mul(&result, &t0)

	// Step 67: result = x^0x9948a20000000000
	result.nSquareCompressed(41)
	result.Decompress(&result)

	// Step 68: result = x^0x9948a20000000001
	z.Mul(x, &result)

	return z
}

// MulBy034 multiplication by sparse element (c0,0,0,c3,c4,0)
func (z *E6) MulBy034(c0, c3, c4 *fp.Element) *E6 {

	var a, b, d E3

	a.MulByElement(&z.B0, c0)

	b.Set(&z.B1)
	b.MulBy01(c3, c4)

	c0.Add(c0, c3)
	d.Add(&z.B0, &z.B1)
	d.MulBy01(c0, c4)

	z.B1.Add(&a, &b).Neg(&z.B1).Add(&z.B1, &d)
	z.B0.MulByNonResidue(&b).Add(&z.B0, &a)

	return z
}

// Mul034By034 multiplication of sparse element (c0,0,0,c3,c4,0) by sparse element (d0,0,0,d3,d4,0)
func (z *E6) Mul034By034(d0, d3, d4, c0, c3, c4 *fp.Element) *E6 {
	var tmp, x0, x3, x4, x04, x03, x34 fp.Element
	x0.Mul(c0, d0)
	x3.Mul(c3, d3)
	x4.Mul(c4, d4)
	tmp.Add(c0, c4)
	x04.Add(d0, d4).
		Mul(&x04, &tmp).
		Sub(&x04, &x0).
		Sub(&x04, &x4)
	tmp.Add(c0, c3)
	x03.Add(d0, d3).
		Mul(&x03, &tmp).
		Sub(&x03, &x0).
		Sub(&x03, &x3)
	tmp.Add(c3, c4)
	x34.Add(d3, d4).
		Mul(&x34, &tmp).
		Sub(&x34, &x3).
		Sub(&x34, &x4)

	z.B0.A0.MulByNonResidue(&x4).
		Add(&z.B0.A0, &x0)
	z.B0.A1.Set(&x3)
	z.B0.A2.Set(&x34)
	z.B1.A0.Set(&x03)
	z.B1.A1.Set(&x04)
	z.B1.A2.SetZero()

	return z
}
